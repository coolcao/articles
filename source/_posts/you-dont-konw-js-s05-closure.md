---
title: 学习笔记-你不知道的js-作用域闭包
date: 2016-11-18 00:17:05
tags: [js,闭包]
categories:
- 学习笔记
- 你不知道的js
---

Javascript中闭包无处不在，你只需要能够识别并拥抱它。　
闭包是基于词法作用域书写代码所产生的自然结果，你甚至不需要为了利用它们而有意识的创建闭包。

<!--more-->

## 实质问题
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
```Javascript
function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}
var baz = foo();
baz();  //2,这就是闭包
```
函数bar()的词法作用域能够访问foo()的内部作用域。然后我们将bar()函数本身当作一个值类型进行传递。在这个例子中，我们将bar所引用的函数对象本身当作返回值。
在foo()执行后，其返回值（也就是内部的bar()函数）赋值给变量baz并调用baz()，实际上只是通过不同的标识符调用了内部的函数bar().
bar()显然可以被正确执行，但是它是在自己定义的词法作用域*以外*的地方执行.
foo()执行后，由于baz仍对bar()函数有引用，因此foo内部作用域依然存在，没有被垃圾回收。bar()依然持有对该作用域的引用，而这个引用就是闭包。
当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。

## 熟悉的闭包
```Javascript
function wait(message){
    setTimeout(function timer(){
        console.log(message);
    },1000)
}
wait('hello,closure');
```
将一个内部函数timer传递给setTimeout()。timer具有涵盖wait()作用域的闭包，因此还保有对变量message的引用。wait()执行1000毫秒后，**他的内部作用域并不会消失**，timer函数依然保有wait()作用域的闭包。
> 这里有个疑问，如果wait()函数执行后，它的内部作用域不会消失，那么是不是意味着垃圾回收机制永远不会回收？或者什么时候回收？

## 循环和闭包
要说明闭包，for循环是常用的例子：
```Javascript
for(var i=1;i<=5;i++){
    setTimeout(function timer(){
        console.log(i);
    },i*1000);
}
```
写这样的代码，可能预期是输出数字1~5，每秒一个，但实际却是，这段代码在运行时，以每秒一次的频率输出5次6.
延迟函数的回调会在循环结束时才执行，当定时器运行时，即使每个迭代中执行的是setTimeout(..,0)，所有的回调函数依然是在循环结束后才执行。因此会每次输出一个6.
这里的缺陷是，我们试图假设循环中每个迭代在运行时都会给自己捕获一个i的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是他们都**被封闭在一个共享的全局作用域中**，因此实际上只有一个i.

我们需要更多的闭包作用域来隔离，特别是在循环的过程中每个迭代都需要一个闭包作用域。

```Javascript
for (var i = 1; i <= 5 ; i++) {
    (function(){
        var j = i;
        setTimeout(function timer() {
            console.log(j);
        },j*1000);
    })();
}
```
这样就可以了。我们为每个迭代都创建一个闭包作用域，然后将i的副本赋值给每个闭包中的j，这里timer()执行的时候访问的就是每个闭包作用域中的变量j.
我们可以将代码改良一下：
```Javascript
for (var i = 1; i <= 5 ; i++) {
    (function(j){
        setTimeout(function timer() {
            console.log(j);
        },j*1000);
    })(i);
}
```

## let与块作用域
上面的例子中，每次迭代时，我们都会创建一个新的作用域，或者说，每次迭代我们都**需要一个块作用域**。
在第三章中，我们已经知道了es6的let，也做个实验说过。
```Javascript
for (let i = 1; i <= 5; i++) {
    console.log(i);
}
```
for循环头部的let声明还会有一个特殊的行为，这个行为指出**变量在循环的过程中不止被声明一次，每次迭代都会声明，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量**。
