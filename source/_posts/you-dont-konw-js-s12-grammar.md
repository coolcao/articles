---
title: 学习笔记-你不知道的js-语法
date: 2016-12-14 22:35:28
tags: [js]
categories:
- 学习笔记
- 你不知道的js
---

## 语句和表达式
--------
### 语句的结果值
语句都有一个结果值，获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示执行的最后一条语句的结果值。

以赋值表达式`var b=1;`为例，其结果值是赋给b的值1，但 **规范定义var的结果值是undefined** 。如果在控制台中输入`var b=1;`会得到结果值undefined，而非42。

但我们在代码中是没有办法获得这个结果值的。具体解决办法比较复杂，首先得弄清除为什么要获得语句的结果值。

<!--more-->

先来看看其他语句的结果值。比如代码块`{..}`的结果值是其最后一个语句/表达式的结果值。
例如：

```js
var b;
if(true){
    b = 1 + 1;
}
```
在控制台输入以上代码会显示2,即最后一个表达式`b = 1 + 1`的结果值。

**代码块的结果值就如同一个隐式的返回，即返回最后一个语句的结果值。**

但是下面代码无法运行：

```js
var a,b;
a = if(true){
    b = 1 + 1;
}
```

因为 **语法不允许我们获得语句的结果值并将其赋值给另一个变量**

那如何从能或得语句的结果值呢？可以使用eval(..)，但是并不推荐使用eval(..)这个操作，因此，略过。

在ES7有一个“do表达式”的提案，类似下面这样：

```js
var a,b;
a = do {
    if(true){
        b = 1 + 1;
    }
}
console.log(a); //2
```

上面例子中，do表达式执行一个代码块，包含一个或多个语句，并返回其中最后一个语句的结果值，然后赋值给变量a。

### 表达式的副作用

#### 函数

最常见有副作用的表达式是函数调用：

```js
function foo(){
    a = a + 1;
}
var a = 1;
foo();  //结果值：undefined，副作用：a的值被改变
```

函数如果有return，则结果值是其return的值，如果没有，那么结果值是undefined。

### 递增/递减运算符
 
递增运算符`++`和递减运算符`--`都是一元运算符，他们既可以用在操作数之前，也可以用在操作数之后。
`++`在前面时，如 `++a` ，它的副作用（将a递增）产生在表达式返回结果值之前，而`a++`的副作用则产生在之后。

> ++a++ 会产生ReferenceError错误，因为运算符需要将产生的副作用赋值给一个变量。以 ++a++ 为例，它首先执行 a++ ，返回2,然后执行 2++ ，这时会产生ReferenceError错误，因为， ++ 无法直接在 2 这样的值上产生副作用。
> 

### 赋值运算符 ==

```js
var a;
a = 42;
a;
```

a = 42 中的 = 运算符看起来没有什么副作用，实际上它的结果值是 42，它的副作用是将42赋值给a。

多个赋值语句串联时，赋值表达式的结果值就能派上用场了。

```js
var a,b,c;
a = b = c = 42;
```

这里 c = 42（副作用是将c赋值42） 的结果值是42，然后 b = 42（副作用是将b赋值42） 的结果值也是 42，最后是 a = 42(副作用是将a赋值42)。

> 链式赋值常常被误用，例如 var a = b = 42，看似和上面例子差不多，其实不是。如果变量b没有在作用域中像 var b这样声明过，则 var a = b = 42 不会对变量b进行声明。在严格模式下会产生错误，或者无意中会创建一个全局变量b。
> 

### 上下文规则 {}
#### 大括号
##### 对象常量
用大括号定义对象常量

```js
var obj = {
    name:'coolcao',
    age:23
}
```

##### 代码块

```js
[] + {};    //"[object Object]"
{} + [];    // 0
```

第一行代码中，{}出现在+运算符之后，因此它被当作一个值（空对象）来处理。
第二行代码中，{}被当作一个独立的空代码块，不执行任何操作。所以，结果相当于是 `+ []` 的结果，是0。

##### 对象结构
ES6开始，{}也可以用于结构赋值。

```js
function getData(){
    return {
        a:42,
        b:'foo'
    }
}

var {a,b} = getData();

console.log(a,b);   //42 "foo"
```

## 运算符优先级

```js
var a = 42;
var b = 'foo';
var c = [1,2,3];

a && b || c;
a || b && c;
```

&& 的优先级比 || 高。

因此上面的结果，a && b || c 的结果是 'foo',而 a || b && c 的结果是 42.

## 自动分号
有时js会自动为代码补上缺失的分号，即自动分号插入（ASI）
只有在代码行末尾与换行符之间除了 **空格** 和 **注释** 之外没有别的内容时，它才会这样做。

## 错误
### 提前使用变量
ES6定义了一个新的概念：TDZ(暂时性死区)
TDZ指的是由于代码中的变量还没有初始化而不能被引用的情况。

```js
{
    a = 2;  //ReferenceError
    let a;
}
```
a = 2试图在let a初始化a之前使用该变量（其作用域在{}），这里就是a的TDZ，会产生错误。

**注意：这里使用的let，区别于var，如果是var则不会报错。因为var的作用域和let不同，以及变量提升。**

对未声明变量使用 typeof 不会产生错误，但在TDZ中却会报错：

```js
{
    typeof a;   //undefined
    typeof b;   //ReferenceError
    let b;
}
```


## 函数参数
在ES6中添加了一个默认参数，这里默认参数也会出现TDZ错误：

```js
var b = 2;
function foo(a = 42,b = a + b + 5){
    //..
}
```
对于函数foo的第二个参数b，= 右边的b就是一个TDZ，所以上面这个例子会报错。

在ES6中如果参数 **被省略** 或者 **值是undefined** ，则取该参数的默认参数。

## try..finally

```js
function foo(){
    try{
        return 42;
    }
    finally{
        console.log('hello');
    }
    console.log('never runs');
}
console.log(foo());
// "hello"
// 42
```

这里return 42先执行，并将foo()函数的返回值设置为42，然后try执行完毕，接着执行finally。最后foo()函数执行完毕，console.log(foo())显示返回值。

try中的throw也是如此。

finally中的return会覆盖try和catch中的return的返回值：

```js
function baz(){
    try{
        return 42;
    }
    finally{
        //覆盖前面的 42
        return 'hello';
    }
}
baz();  //"hello"
```

## switch

```js
switch(a){
    case 2:
        //...
        break;
    case 3:
        //..
        break;
    case 4:
        //..
        break;
}
```

a和case表达式的匹配算法与`====`相同。通常case语句中的switch都是简单值。
但是有些时候，可能需要通过强制类型转换来进行匹配，这时候需要做一些变换：

```js
var a = '1';
switch(true){
    case a == 1:
        //..
        break;
    case a == 2:
        //..
        break;
    default:
        //..
        break;
}
```


